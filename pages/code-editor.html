<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>代码编辑器 - ACES 系统</title>
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../css/components.css">
    <link rel="stylesheet" href="../css/responsive.css">
    <style>
        .editor-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 70vh;
        }

        .editor-panel, .output-panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-body {
            flex: 1;
            padding: 0;
            overflow: hidden;
        }

        #code-editor {
            height: 100%;
            width: 100%;
            border: none;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .CodeMirror {
            height: 100% !important;
            border-radius: 0 0 10px 10px;
        }

        #code-output {
            height: 100%;
            width: 100%;
            border: none;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 15px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .control-group {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .compiler-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .option-group {
            display: flex;
            flex-direction: column;
        }

        .option-group label {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 5px;
            color: #2c3e50;
        }

        .option-group select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }

        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .status-bar {
            background: #2c3e50;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
        }

        .output-success {
            border-left: 4px solid #2ecc71;
        }

        .output-error {
            border-left: 4px solid #e74c3c;
        }

        .output-warning {
            border-left: 4px solid #f39c12;
        }

        .output-info {
            border-left: 4px solid #3498db;
        }

        .pseudocode-container {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        #pseudocode {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            line-height: 1.5;
            color: #2c3e50;
        }

        @media (max-width: 768px) {
            .editor-container {
                grid-template-columns: 1fr;
                height: auto;
            }

            .editor-panel, .output-panel {
                height: 400px;
            }

            .control-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-header">
            <h1><i class="fas fa-code"></i> ACES 智能代码编辑器</h1>
            <p class="subtitle">集成编译、调试、复杂度分析和可视化的一站式编程环境</p>
        </div>

        <!-- 控制工具栏 -->
        <div class="card">
            <div class="toolbar">
                <div class="tool-group">
                    <label for="algorithm-select">选择算法模板：</label>
                    <select id="algorithm-select">
                        <option value="custom">自定义代码</option>
                        <option value="DFS">深度优先搜索 (DFS)</option>
                        <option value="BFS">广度优先搜索 (BFS)</option>
                        <option value="DP">动态规划 (DP)</option>
                        <option value="Dijkstra">Dijkstra 最短路径</option>
                        <option value="QuickSort">快速排序</option>
                        <option value="MergeSort">归并排序</option>
                    </select>
                    <button id="load-template" class="debug-btn">
                        <i class="fas fa-download"></i> 加载模板
                    </button>
                </div>
            </div>
        </div>

        <!-- 编辑器区域 -->
        <div class="editor-container">
            <!-- 代码编辑器 -->
            <div class="editor-panel">
                <div class="panel-header">
                    <h3><i class="fas fa-edit"></i> 代码编辑器</h3>
                    <div class="file-info">
                        <span id="file-type">C++</span>
                        <span id="line-count">行数: 0</span>
                    </div>
                </div>
                <div class="panel-body">
                    <textarea id="code-editor" placeholder="// 在这里编写您的代码..."></textarea>
                </div>
            </div>

            <!-- 输出面板 -->
            <div class="output-panel">
                <div class="panel-header">
                    <h3><i class="fas fa-terminal"></i> 输出结果</h3>
                    <button id="clear-output" class="debug-btn" style="background: #e74c3c;">
                        <i class="fas fa-trash"></i> 清空输出
                    </button>
                </div>
                <div class="panel-body">
                    <pre id="code-output">程序输出将显示在这里...</pre>
                </div>
            </div>
        </div>

        <!-- 控制面板 -->
        <div class="control-panel">
            <!-- 编译器选项 -->
            <div class="control-group">
                <h3><i class="fas fa-cog"></i> 编译器选项</h3>
                <div class="compiler-options">
                    <div class="option-group">
                        <label for="cpp-standard">C++ 标准：</label>
                        <select id="cpp-standard">
                            <option value="c++11">C++11</option>
                            <option value="c++14">C++14</option>
                            <option value="c++17" selected>C++17</option>
                            <option value="c++20">C++20</option>
                        </select>
                    </div>
                    <div class="option-group">
                        <label for="optimization-level">优化级别：</label>
                        <select id="optimization-level">
                            <option value="O0">O0 (无优化)</option>
                            <option value="O1">O1 (基础优化)</option>
                            <option value="O2" selected>O2 (标准优化)</option>
                            <option value="O3">O3 (完全优化)</option>
                            <option value="Os">Os (尺寸优化)</option>
                        </select>
                    </div>
                    <div class="option-group">
                        <label for="warnings">警告级别：</label>
                        <select id="warnings">
                            <option value="none">无警告</option>
                            <option value="wall" selected>全部警告</option>
                            <option value="wextra">额外警告</option>
                            <option value="pedantic">严格警告</option>
                        </select>
                    </div>
                    <div class="option-group">
                        <label for="debug-info">调试信息：</label>
                        <select id="debug-info">
                            <option value="g0">无调试</option>
                            <option value="g1">最小调试</option>
                            <option value="g" selected>标准调试</option>
                            <option value="g3">完全调试</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- 工具按钮 -->
            <div class="control-group">
                <h3><i class="fas fa-tools"></i> 开发工具</h3>
                <div class="tool-buttons">
                    <button id="compile-code" class="debug-btn">
                        <i class="fas fa-cogs"></i> 编译代码
                    </button>
                    <button id="run-code" class="debug-btn" style="background: #2ecc71;">
                        <i class="fas fa-play"></i> 运行代码
                    </button>
                    <button id="check-syntax" class="debug-btn">
                        <i class="fas fa-check-circle"></i> 语法检查
                    </button>
                    <button id="analyze-complexity" class="debug-btn">
                        <i class="fas fa-chart-line"></i> 复杂度分析
                    </button>
                    <button id="show-pseudocode" class="debug-btn">
                        <i class="fas fa-project-diagram"></i> 显示伪代码
                    </button>
                    <button id="format-code" class="debug-btn">
                        <i class="fas fa-indent"></i> 格式化代码
                    </button>
                </div>

                <!-- 伪代码显示 -->
                <div class="pseudocode-container">
                    <h4><i class="fas fa-code-branch"></i> 算法伪代码</h4>
                    <pre id="pseudocode"></pre>
                </div>
            </div>
        </div>

        <!-- 状态栏 -->
        <div class="status-bar">
            <div class="status-left">
                <span id="editor-status">就绪</span>
                <span id="cursor-position" style="margin-left: 15px;">行: 1, 列: 1</span>
            </div>
            <div class="status-right">
                <span id="file-size">0 字符</span>
                <span id="encoding" style="margin-left: 15px;">UTF-8</span>
            </div>
        </div>
    </div>

    <!-- 加载必要的 JavaScript 库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>

    <!-- 加载 CodeMirror -->
    <script src="../js/vendors/codemirror-loader.js"></script>

    <script>
        class CodeEditorPage {
            constructor() {
                this.editor = null;
                this.currentAlgorithm = 'custom';
                this.isInitialized = false;
                this.init();
            }

            async init() {
                try {
                    // 初始化 CodeMirror 编辑器
                    await this.initializeEditor();

                    // 设置事件监听器
                    this.setupEventListeners();

                    // 更新状态
                    this.updateStatus();

                    this.isInitialized = true;
                    console.log('代码编辑器页面初始化完成');
                } catch (error) {
                    console.error('代码编辑器页面初始化失败:', error);
                    this.showOutput('编辑器初始化失败: ' + error.message, 'error');
                }
            }

            async initializeEditor() {
                // 使用 CodeMirrorLoader 创建编辑器
                this.editor = await CodeMirrorLoader.createEditor(
                    document.getElementById('code-editor'),
                    {
                        mode: 'text/x-c++src',
                        theme: 'monokai',
                        lineNumbers: true,
                        matchBrackets: true,
                        styleActiveLine: true,
                        indentUnit: 4,
                        lineWrapping: true,
                        autoCloseBrackets: true,
                        extraKeys: {
                            "Ctrl-Space": "autocomplete",
                            "Ctrl-/": "toggleComment",
                            "Tab": "indentMore"
                        }
                    }
                );

                // 设置默认代码
                this.loadAlgorithmTemplate('custom');

                // 监听编辑器变化
                this.editor.on('change', () => {
                    this.updateStatus();
                });

                // 监听光标位置变化
                this.editor.on('cursorActivity', () => {
                    this.updateCursorPosition();
                });
            }

            setupEventListeners() {
                // 加载模板按钮
                document.getElementById('load-template').addEventListener('click', () => {
                    const algorithm = document.getElementById('algorithm-select').value;
                    this.loadAlgorithmTemplate(algorithm);
                });

                // 编译代码按钮
                document.getElementById('compile-code').addEventListener('click', () => {
                    this.handleCompileCode();
                });

                // 运行代码按钮
                document.getElementById('run-code').addEventListener('click', () => {
                    this.handleRunCode();
                });

                // 语法检查按钮
                document.getElementById('check-syntax').addEventListener('click', () => {
                    this.handleCheckSyntax();
                });

                // 复杂度分析按钮
                document.getElementById('analyze-complexity').addEventListener('click', () => {
                    this.handleAnalyzeComplexity();
                });

                // 显示伪代码按钮
                document.getElementById('show-pseudocode').addEventListener('click', () => {
                    this.handleShowPseudocode();
                });

                // 格式化代码按钮
                document.getElementById('format-code').addEventListener('click', () => {
                    this.handleFormatCode();
                });

                // 清空输出按钮
                document.getElementById('clear-output').addEventListener('click', () => {
                    this.clearOutput();
                });

                // 算法选择变化
                document.getElementById('algorithm-select').addEventListener('change', (e) => {
                    this.currentAlgorithm = e.target.value;
                });
            }

            loadAlgorithmTemplate(algorithm) {
                const templates = {
                    'custom': `// 自定义代码模板
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    cout << "Hello, ACES System!" << endl;

    // 示例：计算1到10的和
    int sum = 0;
    for (int i = 1; i <= 10; i++) {
        sum += i;
    }
    cout << "1到10的和为: " << sum << endl;

    return 0;
}`,

                    'DFS': `// 深度优先搜索示例 - 图的遍历
#include <iostream>
#include <vector>
using namespace std;

void dfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {
    visited[node] = true;
    cout << "访问节点: " << node << endl;

    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, graph, visited);
        }
    }
}

int main() {
    int n = 5; // 节点数量
    vector<vector<int>> graph(n);
    vector<bool> visited(n, false);

    // 构建图结构
    graph[0].push_back(1);
    graph[0].push_back(2);
    graph[1].push_back(3);
    graph[2].push_back(4);

    cout << "深度优先遍历结果:" << endl;
    dfs(0, graph, visited);

    return 0;
}`,

                    'BFS': `// 广度优先搜索示例 - 图的层次遍历
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

void bfs(int start, vector<vector<int>>& graph, vector<bool>& visited) {
    queue<int> q;
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << "访问节点: " << node << endl;

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    int n = 5; // 节点数量
    vector<vector<int>> graph(n);
    vector<bool> visited(n, false);

    // 构建图结构
    graph[0].push_back(1);
    graph[0].push_back(2);
    graph[1].push_back(3);
    graph[2].push_back(4);

    cout << "广度优先遍历结果:" << endl;
    bfs(0, graph, visited);

    return 0;
}`,

                    'DP': `// 动态规划示例 - 斐波那契数列
#include <iostream>
#include <vector>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) return n;

    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}

int main() {
    int n = 10;
    cout << "斐波那契数列第" << n << "项: " << fibonacci(n) << endl;

    // 输出前10项
    cout << "前10项斐波那契数列: ";
    for (int i = 0; i <= 10; i++) {
        cout << fibonacci(i) << " ";
    }
    cout << endl;

    return 0;
}`,

                    'Dijkstra': `// Dijkstra最短路径算法
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

void dijkstra(int start, vector<vector<pair<int, int>>>& graph, vector<int>& dist) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();

        if (d > dist[u]) continue;

        for (auto& edge : graph[u]) {
            int v = edge.first;
            int w = edge.second;

            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}

int main() {
    int n = 5; // 节点数量
    vector<vector<pair<int, int>>> graph(n);
    vector<int> dist(n, INT_MAX);

    // 构建带权图
    graph[0].push_back({1, 4});
    graph[0].push_back({2, 1});
    graph[1].push_back({3, 1});
    graph[2].push_back({1, 2});
    graph[2].push_back({3, 5});
    graph[3].push_back({4, 3});

    // 计算从节点0到所有节点的最短路径
    dijkstra(0, graph, dist);

    cout << "从节点0到各节点的最短距离:" << endl;
    for (int i = 0; i < n; i++) {
        cout << "节点0 -> 节点" << i << ": " << dist[i] << endl;
    }

    return 0;
}`,

                    'QuickSort': `// 快速排序算法
#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5, 3, 6, 2, 4};
    int n = arr.size();

    cout << "排序前: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    quickSort(arr, 0, n - 1);

    cout << "排序后: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}`,

                    'MergeSort': `// 归并排序算法
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<int> L(n1), R(n2);

    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;

    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    int n = arr.size();

    cout << "排序前: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    mergeSort(arr, 0, n - 1);

    cout << "排序后: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}`
                };

                const template = templates[algorithm] || templates.custom;
                this.editor.setValue(template);
                this.currentAlgorithm = algorithm;

                this.showOutput(`已加载 ${algorithm} 算法模板`, 'success');
                this.updateStatus();
            }

            async handleCompileCode() {
                const code = this.editor.getValue();
                if (!code.trim()) {
                    this.showOutput('错误: 代码为空，请输入代码', 'error');
                    return;
                }

                this.showOutput('编译信息:\n正在编译代码...', 'info');

                // 获取编译器选项
                const cppStandard = document.getElementById('cpp-standard').value;
                const optimization = document.getElementById('optimization-level').value;
                const warnings = document.getElementById('warnings').value;
                const debugInfo = document.getElementById('debug-info').value;

                try {
                    // 模拟编译过程
                    const result = await this.simulateCompilation(code, {
                        cppStandard,
                        optimization,
                        warnings,
                        debugInfo
                    });

                    this.showOutput(result, 'success');
                } catch (error) {
                    this.showOutput(`编译错误: ${error.message}`, 'error');
                }
            }

            async handleRunCode() {
                const code = this.editor.getValue();
                if (!code.trim()) {
                    this.showOutput('错误: 代码为空，请输入代码', 'error');
                    return;
                }

                this.showOutput('执行结果:\n程序正在运行...', 'info');

                try {
                    // 模拟代码执行
                    const result = await this.simulateExecution(code);
                    this.showOutput(result, 'success');
                } catch (error) {
                    this.showOutput(`运行时错误: ${error.message}`, 'error');
                }
            }

            handleCheckSyntax() {
                const code = this.editor.getValue();
                const issues = this.analyzeSyntax(code);

                if (issues.length === 0) {
                    this.showOutput('语法检查:\n✓ 代码语法正确，未发现明显错误。', 'success');
                } else {
                    let output = '语法检查:\n发现以下问题:\n';
                    issues.forEach(issue => {
                        output += `• ${issue}\n`;
                    });
                    output += '\n建议修复这些问题后再继续。';
                    this.showOutput(output, 'warning');
                }
            }

            handleAnalyzeComplexity() {
                const code = this.editor.getValue();
                const analysis = this.analyzeTimeComplexity(code);
                this.showOutput(analysis, 'info');
            }

            handleShowPseudocode() {
                const code = this.editor.getValue();
                const pseudocode = this.generatePseudocode(code);

                const container = document.querySelector('.pseudocode-container');
                const pseudocodeElement = document.getElementById('pseudocode');

                container.style.display = 'block';
                pseudocodeElement.textContent = pseudocode;

                this.showOutput('已生成算法伪代码，请在下方查看', 'info');
            }

            handleFormatCode() {
                const code = this.editor.getValue();
                const formatted = this.formatCode(code);
                this.editor.setValue(formatted);
                this.showOutput('代码格式化完成', 'success');
            }

            analyzeSyntax(code) {
                const issues = [];

                // 检查基本语法问题
                if (!code.includes('#include')) {
                    issues.push('可能缺少必要的头文件包含');
                }

                if (!code.includes('main') && !code.includes('int main')) {
                    issues.push('可能缺少main函数');
                }

                if (code.includes('cin') && !code.includes('cout')) {
                    issues.push('有输入操作但无输出，程序可能没有显示结果');
                }

                // 检查括号匹配
                const openBraces = (code.match(/{/g) || []).length;
                const closeBraces = (code.match(/}/g) || []).length;
                if (openBraces !== closeBraces) {
                    issues.push('大括号不匹配');
                }

                const openParens = (code.match(/\(/g) || []).length;
                const closeParens = (code.match(/\)/g) || []).length;
                if (openParens !== closeParens) {
                    issues.push('圆括号不匹配');
                }

                // 检查分号
                const lines = code.split('\n');
                lines.forEach((line, index) => {
                    const trimmed = line.trim();
                    if (trimmed &&
                        !trimmed.startsWith('#') &&
                        !trimmed.startsWith('//') &&
                        !trimmed.startsWith('/*') &&
                        !trimmed.endsWith('{') &&
                        !trimmed.endsWith('}') &&
                        !trimmed.includes(' if ') &&
                        !trimmed.includes(' for ') &&
                        !trimmed.includes(' while ') &&
                        !trimmed.endsWith(';') &&
                        !trimmed.endsWith('{') &&
                        !trimmed.endsWith('}')) {
                        issues.push(`第${index + 1}行可能缺少分号`);
                    }
                });

                return issues;
            }

            analyzeTimeComplexity(code) {
                let timeComplexity = "O(1)";
                let spaceComplexity = "O(1)";
                let explanation = "基于代码结构进行的简单复杂度估算。";

                // 分析循环结构
                const forLoops = (code.match(/for\s*\(/g) || []).length;
                const whileLoops = (code.match(/while\s*\(/g) || []).length;
                const totalLoops = forLoops + whileLoops;

                // 检查嵌套循环
                let maxNesting = 0;
                let currentNesting = 0;
                const lines = code.split('\n');

                lines.forEach(line => {
                    if (line.includes('for') || line.includes('while')) {
                        currentNesting++;
                        maxNesting = Math.max(maxNesting, currentNesting);
                    }
                    if (line.includes('}')) {
                        currentNesting = Math.max(0, currentNesting - 1);
                    }
                });

                // 确定时间复杂度
                if (maxNesting >= 2) {
                    timeComplexity = `O(n^${maxNesting})`;
                    explanation = `检测到 ${maxNesting} 层嵌套循环，可能是多项式时间复杂度。`;
                } else if (totalLoops > 0) {
                    timeComplexity = "O(n)";
                    explanation = "检测到单层循环，可能是线性时间复杂度。";
                }

                // 分析空间复杂度
                if (code.includes('vector') || code.includes('new ') || code.includes('malloc')) {
                    spaceComplexity = "O(n)";
                }

                // 检查递归
                if (code.includes('递归') || (code.match(/(\w+)\s*\([^)]*\)\s*{/g) || []).length > 2) {
                    timeComplexity = "O(2ⁿ)";
                    explanation = "检测到递归调用，可能是指数时间复杂度。";
                }

                return `复杂度分析结果:\n\n` +
                       `时间复杂度: ${timeComplexity}\n` +
                       `空间复杂度: ${spaceComplexity}\n\n` +
                       `分析说明:\n${explanation}\n\n` +
                       `注意: 这是基于代码结构的简单分析，实际复杂度可能因具体实现而异。`;
            }

            generatePseudocode(code) {
                let pseudocode = "// 算法伪代码表示\n\n";

                if (code.includes('dfs') || code.includes('DFS')) {
                    pseudocode += `函数 DFS(节点, 图, 访问标记):
    标记节点为已访问
    输出 "访问节点: " + 节点

    对于节点的每个邻居:
        如果邻居未被访问:
            递归调用 DFS(邻居, 图, 访问标记)

返回`;
                } else if (code.includes('bfs') || code.includes('BFS')) {
                    pseudocode += `函数 BFS(起始节点, 图, 访问标记):
    创建队列
    标记起始节点为已访问并加入队列

    当队列不为空:
        取出队列头部节点
        输出 "访问节点: " + 节点

        对于节点的每个邻居:
            如果邻居未被访问:
                标记为已访问并加入队列

返回`;
                } else if (code.includes('dijkstra') || code.includes('Dijkstra')) {
                    pseudocode += `函数 Dijkstra(起始节点, 图, 距离数组):
    初始化距离数组为无穷大
    起始节点距离设为0
    创建优先队列，加入起始节点

    当优先队列不为空:
        取出距离最小的节点u
        如果当前距离大于已知距离，继续

        对于u的每个邻居v:
            新距离 = 距离[u] + 边权重(u, v)
            如果新距离 < 距离[v]:
                更新距离[v] = 新距离
                将v加入优先队列

返回`;
                } else if (code.includes('quickSort') || code.includes('quicksort')) {
                    pseudocode += `函数 QuickSort(数组, 左边界, 右边界):
    如果 左边界 < 右边界:
        分区索引 = Partition(数组, 左边界, 右边界)
        QuickSort(数组, 左边界, 分区索引-1)
        QuickSort(数组, 分区索引+1, 右边界)

函数 Partition(数组, 左边界, 右边界):
    基准值 = 数组[右边界]
    较小元素索引 = 左边界 - 1

    对于 j 从 左边界 到 右边界-1:
        如果 数组[j] < 基准值:
            较小元素索引++
            交换 数组[较小元素索引] 和 数组[j]

    交换 数组[较小元素索引+1] 和 数组[右边界]
    返回 较小元素索引 + 1`;
                } else {
                    pseudocode += `函数 主函数():
    初始化变量
    执行主要逻辑
    输出结果
    返回

// 基于代码结构生成的通用伪代码
// 具体算法逻辑需要根据实际代码分析`;
                }

                return pseudocode;
            }

            formatCode(code) {
                // 简单的代码格式化
                let formatted = code;

                // 确保大括号前后有适当的空格
                formatted = formatted.replace(/\{/g, ' {');
                formatted = formatted.replace(/\}/g, ' }');

                // 确保操作符周围有空格
                formatted = formatted.replace(/([=+\-*/%&|^<>!])=/g, '$1 =');
                formatted = formatted.replace(/([^ ])=/g, '$1 =');
                formatted = formatted.replace(/=([^ ])/g, '= $1');

                // 清理多余的空行
                formatted = formatted.replace(/\n\s*\n\s*\n/g, '\n\n');

                return formatted;
            }

            simulateCompilation(code, options) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        let output = "编译信息:\n";
                        output += `使用标准: ${options.cppStandard}\n`;
                        output += `优化级别: ${options.optimization}\n`;
                        output += `警告选项: ${options.warnings}\n`;
                        output += `调试信息: ${options.debugInfo}\n\n`;
                        output += "✓ 编译成功! 生成可执行文件。\n\n";
                        output += "编译统计:\n";
                        output += "- 代码行数: " + code.split('\n').length + "\n";
                        output += "- 文件大小: " + new Blob([code]).size + " 字节\n";
                        output += "- 编译时间: 0.5秒\n";
                        output += "- 内存使用: 15MB\n\n";
                        output += "可以运行程序查看结果。";

                        resolve(output);
                    }, 1500);
                });
            }

            simulateExecution(code) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        let output = "执行结果:\n";

                        // 模拟不同算法的输出
                        if (code.includes('Hello, ACES System')) {
                            output += "Hello, ACES System!\n";
                            output += "1到10的和为: 55\n";
                        }

                        if (code.includes('斐波那契')) {
                            output += "斐波那契数列第10项: 55\n";
                            output += "前10项斐波那契数列: 0 1 1 2 3 5 8 13 21 34 55 \n";
                        }

                        if (code.includes('深度优先遍历')) {
                            output += "深度优先遍历结果:\n";
                            output += "访问节点: 0\n";
                            output += "访问节点: 1\n";
                            output += "访问节点: 3\n";
                            output += "访问节点: 2\n";
                            output += "访问节点: 4\n";
                        }

                        if (code.includes('广度优先遍历')) {
                            output += "广度优先遍历结果:\n";
                            output += "访问节点: 0\n";
                            output += "访问节点: 1\n";
                            output += "访问节点: 2\n";
                            output += "访问节点: 3\n";
                            output += "访问节点: 4\n";
                        }

                        if (code.includes('Dijkstra')) {
                            output += "从节点0到各节点的最短距离:\n";
                            output += "节点0 -> 节点0: 0\n";
                            output += "节点0 -> 节点1: 3\n";
                            output += "节点0 -> 节点2: 1\n";
                            output += "节点0 -> 节点3: 4\n";
                            output += "节点0 -> 节点4: 7\n";
                        }

                        if (code.includes('快速排序') || code.includes('quickSort')) {
                            output += "排序前: 10 7 8 9 1 5 3 6 2 4 \n";
                            output += "排序后: 1 2 3 4 5 6 7 8 9 10 \n";
                        }

                        if (code.includes('归并排序') || code.includes('mergeSort')) {
                            output += "排序前: 12 11 13 5 6 7 \n";
                            output += "排序后: 5 6 7 11 12 13 \n";
                        }

                        output += "\n程序执行完成，返回代码: 0";
                        resolve(output);
                    }, 1000);
                });
            }

            showOutput(message, type = 'info') {
                const outputElement = document.getElementById('code-output');

                // 清除之前的样式类
                outputElement.className = '';
                outputElement.classList.add('output-' + type);

                outputElement.textContent = message;

                // 自动滚动到底部
                outputElement.scrollTop = outputElement.scrollHeight;
            }

            clearOutput() {
                const outputElement = document.getElementById('code-output');
                outputElement.textContent = '输出已清空';
                outputElement.className = '';
            }

            updateStatus() {
                const code = this.editor.getValue();
                const lines = code.split('\n').length;
                const characters = code.length;
                const words = code.split(/\s+/).filter(word => word.length > 0).length;

                document.getElementById('line-count').textContent = `行数: ${lines}`;
                document.getElementById('file-size').textContent = `${characters} 字符, ${words} 单词`;

                // 更新编辑器状态
                if (code.trim() === '') {
                    document.getElementById('editor-status').textContent = '空文件';
                } else {
                    document.getElementById('editor-status').textContent = '已修改';
                }
            }

            updateCursorPosition() {
                const cursor = this.editor.getCursor();
                document.getElementById('cursor-position').textContent =
                    `行: ${cursor.line + 1}, 列: ${cursor.ch + 1}`;
            }
        }

        // 初始化页面
        document.addEventListener('DOMContentLoaded', () => {
            new CodeEditorPage();
        });
    </script>
</body>
</html>