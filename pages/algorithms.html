<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>算法学习 - ACES 系统</title>
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../css/components.css">
    <link rel="stylesheet" href="../css/responsive.css">
    <style>
        .algorithm-categories {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .category-card {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            border-left: 5px solid #3498db;
        }

        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .category-card.sorting { border-left-color: #e74c3c; }
        .category-card.searching { border-left-color: #2ecc71; }
        .category-card.graph { border-left-color: #9b59b6; }
        .category-card.dp { border-left-color: #f39c12; }
        .category-card.greedy { border-left-color: #1abc9c; }

        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .algorithm-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .algorithm-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .algorithm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .algorithm-name {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
        }

        .complexity-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .complexity-good { background: #d4edda; color: #155724; }
        .complexity-fair { background: #fff3cd; color: #856404; }
        .complexity-poor { background: #f8d7da; color: #721c24; }

        .algorithm-meta {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.9em;
            color: #6c757d;
        }

        .difficulty-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }

        .difficulty-easy { background: #2ecc71; }
        .difficulty-medium { background: #f39c12; }
        .difficulty-hard { background: #e74c3c; }

        .algorithm-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s;
        }

        .btn-learn { background: #3498db; color: white; }
        .btn-practice { background: #2ecc71; color: white; }
        .btn-visualize { background: #9b59b6; color: white; }

        .visualization-area {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 400px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .algorithm-detail {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .detail-tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 20px;
        }

        .detail-tab {
            padding: 12px 24px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .detail-tab.active {
            border-bottom-color: #3498db;
            color: #3498db;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        .pseudocode {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .time-complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .time-complexity-table th,
        .time-complexity-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .time-complexity-table th {
            background: #f8f9fa;
            font-weight: bold;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .search-box {
            margin-bottom: 20px;
        }

        .search-box input {
            width: 100%;
            padding: 12px 20px;
            border: 1px solid #ddd;
            border-radius: 25px;
            font-size: 1em;
            transition: all 0.3s;
        }

        .search-box input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .filter-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-header">
            <h1><i class="fas fa-project-diagram"></i> 算法学习中心</h1>
            <p class="subtitle">掌握核心算法，提升编程能力</p>
        </div>

        <!-- 搜索和筛选 -->
        <div class="search-box">
            <input type="text" id="algorithm-search" placeholder="搜索算法...">
        </div>

        <div class="filter-bar">
            <select id="category-filter" class="filter-select">
                <option value="">所有分类</option>
                <option value="sorting">排序算法</option>
                <option value="searching">搜索算法</option>
                <option value="graph">图算法</option>
                <option value="dp">动态规划</option>
                <option value="greedy">贪心算法</option>
            </select>

            <select id="difficulty-filter" class="filter-select">
                <option value="">所有难度</option>
                <option value="easy">简单</option>
                <option value="medium">中等</option>
                <option value="hard">困难</option>
            </select>

            <select id="complexity-filter" class="filter-select">
                <option value="">所有复杂度</option>
                <option value="O(1)">O(1)</option>
                <option value="O(log n)">O(log n)</option>
                <option value="O(n)">O(n)</option>
                <option value="O(n log n)">O(n log n)</option>
                <option value="O(n²)">O(n²)</option>
            </select>
        </div>

        <!-- 算法分类 -->
        <div class="algorithm-categories">
            <div class="category-card sorting" data-category="sorting">
                <h3><i class="fas fa-sort-amount-down"></i> 排序算法</h3>
                <p>学习各种排序算法及其应用场景</p>
                <div class="algorithm-count">8 个算法</div>
            </div>

            <div class="category-card searching" data-category="searching">
                <h3><i class="fas fa-search"></i> 搜索算法</h3>
                <p>掌握高效的数据查找方法</p>
                <div class="algorithm-count">6 个算法</div>
            </div>

            <div class="category-card graph" data-category="graph">
                <h3><i class="fas fa-network-wired"></i> 图算法</h3>
                <p>理解图论和网络算法</p>
                <div class="algorithm-count">12 个算法</div>
            </div>

            <div class="category-card dp" data-category="dp">
                <h3><i class="fas fa-sitemap"></i> 动态规划</h3>
                <p>学习最优子结构和状态转移</p>
                <div class="algorithm-count">10 个算法</div>
            </div>

            <div class="category-card greedy" data-category="greedy">
                <h3><i class="fas fa-gem"></i> 贪心算法</h3>
                <p>掌握局部最优选择策略</p>
                <div class="algorithm-count">7 个算法</div>
            </div>
        </div>

        <!-- 算法列表 -->
        <div id="algorithms-list">
            <div class="algorithm-grid" id="algorithm-grid">
                <!-- 算法卡片将通过 JavaScript 动态生成 -->
            </div>
        </div>

        <!-- 算法详情 -->
        <div id="algorithm-detail" class="algorithm-detail" style="display: none;">
            <div class="algorithm-detail-header">
                <button id="back-to-list" class="debug-btn" style="margin-bottom: 20px;">
                    <i class="fas fa-arrow-left"></i> 返回列表
                </button>
                <h2 id="detail-algorithm-name">算法名称</h2>
                <div class="algorithm-meta">
                    <span id="detail-category"></span>
                    <span id="detail-difficulty"></span>
                    <span id="detail-complexity"></span>
                </div>
            </div>

            <div class="detail-tabs">
                <div class="detail-tab active" data-tab="description">算法描述</div>
                <div class="detail-tab" data-tab="pseudocode">伪代码</div>
                <div class="detail-tab" data-tab="implementation">代码实现</div>
                <div class="detail-tab" data-tab="complexity">复杂度分析</div>
                <div class="detail-tab" data-tab="visualization">可视化</div>
            </div>

            <div class="tab-content active" id="tab-description">
                <div id="algorithm-description">
                    <!-- 算法描述内容 -->
                </div>
            </div>

            <div class="tab-content" id="tab-pseudocode">
                <div class="pseudocode" id="algorithm-pseudocode">
                    <!-- 伪代码内容 -->
                </div>
            </div>

            <div class="tab-content" id="tab-implementation">
                <div class="code-example" id="algorithm-code">
                    <!-- 代码实现 -->
                </div>
                <div class="algorithm-actions" style="margin-top: 20px;">
                    <button class="action-btn btn-learn" id="run-code">
                        <i class="fas fa-play"></i> 运行代码
                    </button>
                    <button class="action-btn btn-practice" id="practice-algorithm">
                        <i class="fas fa-dumbbell"></i> 练习题目
                    </button>
                </div>
            </div>

            <div class="tab-content" id="tab-complexity">
                <h4>时间复杂度分析</h4>
                <table class="time-complexity-table">
                    <thead>
                        <tr>
                            <th>情况</th>
                            <th>时间复杂度</th>
                            <th>说明</th>
                        </tr>
                    </thead>
                    <tbody id="time-complexity-body">
                        <!-- 时间复杂度数据 -->
                    </tbody>
                </table>

                <h4 style="margin-top: 30px;">空间复杂度</h4>
                <div id="space-complexity">
                    <!-- 空间复杂度信息 -->
                </div>

                <h4 style="margin-top: 30px;">适用场景</h4>
                <div id="applications">
                    <!-- 适用场景信息 -->
                </div>
            </div>

            <div class="tab-content" id="tab-visualization">
                <div class="visualization-area" id="algorithm-visualization">
                    <div style="text-align: center; padding: 50px 20px;">
                        <i class="fas fa-chart-bar fa-3x" style="color: #3498db; margin-bottom: 20px;"></i>
                        <h3>算法可视化</h3>
                        <p>选择数据并启动可视化演示</p>
                        <div style="margin-top: 20px;">
                            <button class="debug-btn" id="start-visualization">
                                <i class="fas fa-play"></i> 启动可视化
                            </button>
                            <button class="debug-btn" id="reset-visualization">
                                <i class="fas fa-redo"></i> 重置
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
    <script>
        // 算法数据
        const algorithmsData = {
            sorting: [
                {
                    id: 'quicksort',
                    name: '快速排序',
                    category: 'sorting',
                    difficulty: 'medium',
                    timeComplexity: {
                        best: 'O(n log n)',
                        average: 'O(n log n)',
                        worst: 'O(n²)'
                    },
                    spaceComplexity: 'O(log n)',
                    description: '快速排序是一种高效的排序算法，采用分治策略。通过选择基准元素将数组分为两部分，然后递归排序。',
                    pseudocode: `function quicksort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        quicksort(arr, low, pivot_index - 1)
        quicksort(arr, pivot_index + 1, high)

function partition(arr, low, high):
    pivot = arr[high]
    i = low - 1

    for j from low to high-1:
        if arr[j] <= pivot:
            i = i + 1
            swap arr[i] and arr[j]

    swap arr[i+1] and arr[high]
    return i + 1`,
                    code: `#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}`,
                    applications: ['大规模数据排序', '需要原地排序的场景', '对缓存友好的排序']
                },
                {
                    id: 'mergesort',
                    name: '归并排序',
                    category: 'sorting',
                    difficulty: 'medium',
                    timeComplexity: {
                        best: 'O(n log n)',
                        average: 'O(n log n)',
                        worst: 'O(n log n)'
                    },
                    spaceComplexity: 'O(n)',
                    description: '归并排序是稳定的排序算法，采用分治策略。将数组分成两半，分别排序后合并。',
                    pseudocode: `function mergesort(arr):
    if length(arr) <= 1:
        return arr

    mid = length(arr) // 2
    left = mergesort(arr[0:mid])
    right = mergesort(arr[mid:])

    return merge(left, right)

function merge(left, right):
    result = []
    i = 0, j = 0

    while i < length(left) and j < length(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i = i + 1
        else:
            result.append(right[j])
            j = j + 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result`,
                    code: `#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }

    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];

    for (int p = 0; p < k; p++) {
        arr[left + p] = temp[p];
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}`,
                    applications: ['链表排序', '外部排序', '需要稳定排序的场景']
                }
            ],
            searching: [
                {
                    id: 'binarysearch',
                    name: '二分查找',
                    category: 'searching',
                    difficulty: 'easy',
                    timeComplexity: {
                        best: 'O(1)',
                        average: 'O(log n)',
                        worst: 'O(log n)'
                    },
                    spaceComplexity: 'O(1)',
                    description: '二分查找用于在有序数组中快速查找元素，每次比较都将搜索范围减半。',
                    pseudocode: `function binary_search(arr, target):
    left = 0
    right = length(arr) - 1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            return mid
        else if arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1`,
                    code: `#include <iostream>
#include <vector>
using namespace std;

int binarySearch(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}`,
                    applications: ['有序数组查找', '数据库索引', '游戏中的分数查找']
                }
            ],
            graph: [
                {
                    id: 'dijkstra',
                    name: 'Dijkstra算法',
                    category: 'graph',
                    difficulty: 'medium',
                    timeComplexity: {
                        best: 'O((V+E) log V)',
                        average: 'O((V+E) log V)',
                        worst: 'O((V+E) log V)'
                    },
                    spaceComplexity: 'O(V)',
                    description: 'Dijkstra算法用于在带权图中找到单源最短路径，适用于非负权边。',
                    pseudocode: `function dijkstra(graph, start):
    dist = array of size V, all values infinity
    dist[start] = 0
    priority_queue = min-heap

    for each vertex v in graph:
        priority_queue.insert(v, dist[v])

    while priority_queue is not empty:
        u = priority_queue.extract_min()

        for each neighbor v of u:
            alt = dist[u] + weight(u, v)
            if alt < dist[v]:
                dist[v] = alt
                priority_queue.decrease_key(v, alt)`,
                    code: `#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

void dijkstra(vector<vector<pair<int, int>>>& graph, int start, vector<int>& dist) {
    int n = graph.size();
    dist.assign(n, INT_MAX);
    dist[start] = 0;

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});

    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();

        if (d > dist[u]) continue;

        for (auto& edge : graph[u]) {
            int v = edge.first;
            int w = edge.second;

            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}`,
                    applications: ['路由算法', '网络优化', '地图导航']
                }
            ]
        };

        class AlgorithmsManager {
            constructor() {
                this.currentCategory = null;
                this.currentAlgorithm = null;
                this.filteredAlgorithms = [];
                this.init();
            }

            init() {
                this.renderAlgorithms();
                this.setupEventListeners();
                this.setupFilters();
            }

            renderAlgorithms(category = null) {
                const algorithmGrid = document.getElementById('algorithm-grid');
                let algorithms = [];

                if (category && algorithmsData[category]) {
                    algorithms = algorithmsData[category];
                } else {
                    // 显示所有算法
                    Object.values(algorithmsData).forEach(categoryAlgorithms => {
                        algorithms.push(...categoryAlgorithms);
                    });
                }

                this.filteredAlgorithms = algorithms;
                this.renderAlgorithmCards(algorithms);
            }

            renderAlgorithmCards(algorithms) {
                const algorithmGrid = document.getElementById('algorithm-grid');

                if (algorithms.length === 0) {
                    algorithmGrid.innerHTML = `
                        <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;">
                            <i class="fas fa-search fa-3x" style="margin-bottom: 20px;"></i>
                            <h3>未找到匹配的算法</h3>
                            <p>尝试调整搜索条件或筛选器</p>
                        </div>
                    `;
                    return;
                }

                const cardsHTML = algorithms.map(algorithm => {
                    const complexityClass = this.getComplexityClass(algorithm.timeComplexity.average);

                    return `
                        <div class="algorithm-card" data-algorithm="${algorithm.id}" data-category="${algorithm.category}">
                            <div class="algorithm-header">
                                <div class="algorithm-name">${algorithm.name}</div>
                                <div class="complexity-badge ${complexityClass}">
                                    ${algorithm.timeComplexity.average}
                                </div>
                            </div>

                            <div class="algorithm-meta">
                                <span>
                                    <span class="difficulty-dot difficulty-${algorithm.difficulty}"></span>
                                    ${this.getDifficultyText(algorithm.difficulty)}
                                </span>
                                <span>${this.getCategoryText(algorithm.category)}</span>
                            </div>

                            <p style="color: #666; font-size: 0.9em; margin: 10px 0;">
                                ${algorithm.description.substring(0, 100)}...
                            </p>

                            <div class="algorithm-actions">
                                <button class="action-btn btn-learn" onclick="algorithmsManager.showAlgorithmDetail('${algorithm.id}')">
                                    学习
                                </button>
                                <button class="action-btn btn-practice">
                                    练习
                                </button>
                                <button class="action-btn btn-visualize">
                                    可视化
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');

                algorithmGrid.innerHTML = cardsHTML;
            }

            showAlgorithmDetail(algorithmId) {
                // 查找算法
                let algorithm = null;
                for (const category in algorithmsData) {
                    algorithm = algorithmsData[category].find(algo => algo.id === algorithmId);
                    if (algorithm) break;
                }

                if (!algorithm) return;

                this.currentAlgorithm = algorithm;

                // 隐藏列表，显示详情
                document.getElementById('algorithms-list').style.display = 'none';
                document.getElementById('algorithm-detail').style.display = 'block';

                // 更新详情内容
                this.updateAlgorithmDetail(algorithm);
            }

            updateAlgorithmDetail(algorithm) {
                document.getElementById('detail-algorithm-name').textContent = algorithm.name;
                document.getElementById('detail-category').textContent = this.getCategoryText(algorithm.category);
                document.getElementById('detail-difficulty').innerHTML = `
                    <span class="difficulty-dot difficulty-${algorithm.difficulty}"></span>
                    ${this.getDifficultyText(algorithm.difficulty)}
                `;
                document.getElementById('detail-complexity').textContent = `复杂度: ${algorithm.timeComplexity.average}`;

                // 更新标签页内容
                document.getElementById('algorithm-description').innerHTML = `
                    <h4>算法描述</h4>
                    <p>${algorithm.description}</p>
                `;

                document.getElementById('algorithm-pseudocode').textContent = algorithm.pseudocode;
                document.getElementById('algorithm-code').textContent = algorithm.code;

                // 更新复杂度分析
                this.renderComplexityAnalysis(algorithm);
            }

            renderComplexityAnalysis(algorithm) {
                const timeComplexityBody = document.getElementById('time-complexity-body');
                timeComplexityBody.innerHTML = `
                    <tr>
                        <td>最好情况</td>
                        <td>${algorithm.timeComplexity.best}</td>
                        <td>在最优输入情况下的时间复杂度</td>
                    </tr>
                    <tr>
                        <td>平均情况</td>
                        <td>${algorithm.timeComplexity.average}</td>
                        <td>在随机输入情况下的期望时间复杂度</td>
                    </tr>
                    <tr>
                        <td>最坏情况</td>
                        <td>${algorithm.timeComplexity.worst}</td>
                        <td>在最差输入情况下的时间复杂度</td>
                    </tr>
                `;

                document.getElementById('space-complexity').innerHTML = `
                    <p><strong>空间复杂度:</strong> ${algorithm.spaceComplexity}</p>
                    <p>${this.getSpaceComplexityDescription(algorithm.spaceComplexity)}</p>
                `;

                document.getElementById('applications').innerHTML = `
                    <ul>
                        ${algorithm.applications.map(app => `<li>${app}</li>`).join('')}
                    </ul>
                `;
            }

            setupEventListeners() {
                // 分类卡片点击
                document.querySelectorAll('.category-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const category = card.dataset.category;
                        this.currentCategory = category;
                        this.renderAlgorithms(category);

                        // 更新筛选器
                        document.getElementById('category-filter').value = category;
                    });
                });

                // 返回列表按钮
                document.getElementById('back-to-list').addEventListener('click', () => {
                    document.getElementById('algorithm-detail').style.display = 'none';
                    document.getElementById('algorithms-list').style.display = 'block';
                });

                // 标签页切换
                document.querySelectorAll('.detail-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.dataset.tab;

                        // 更新活动标签
                        document.querySelectorAll('.detail-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        // 显示对应内容
                        document.querySelectorAll('.tab-content').forEach(content => {
                            content.classList.remove('active');
                        });
                        document.getElementById(`tab-${tabName}`).classList.add('active');
                    });
                });

                // 运行代码按钮
                document.getElementById('run-code')?.addEventListener('click', () => {
                    this.runAlgorithmCode();
                });
            }

            setupFilters() {
                // 搜索框
                document.getElementById('algorithm-search').addEventListener('input', (e) => {
                    this.filterAlgorithms();
                });

                // 筛选器
                document.getElementById('category-filter').addEventListener('change', () => {
                    this.filterAlgorithms();
                });

                document.getElementById('difficulty-filter').addEventListener('change', () => {
                    this.filterAlgorithms();
                });

                document.getElementById('complexity-filter').addEventListener('change', () => {
                    this.filterAlgorithms();
                });
            }

            filterAlgorithms() {
                const searchTerm = document.getElementById('algorithm-search').value.toLowerCase();
                const categoryFilter = document.getElementById('category-filter').value;
                const difficultyFilter = document.getElementById('difficulty-filter').value;
                const complexityFilter = document.getElementById('complexity-filter').value;

                let algorithms = [];

                // 获取所有算法或特定分类的算法
                if (categoryFilter) {
                    algorithms = algorithmsData[categoryFilter] || [];
                } else {
                    Object.values(algorithmsData).forEach(categoryAlgorithms => {
                        algorithms.push(...categoryAlgorithms);
                    });
                }

                // 应用筛选
                const filtered = algorithms.filter(algorithm => {
                    const matchesSearch = algorithm.name.toLowerCase().includes(searchTerm) ||
                                         algorithm.description.toLowerCase().includes(searchTerm);
                    const matchesDifficulty = !difficultyFilter || algorithm.difficulty === difficultyFilter;
                    const matchesComplexity = !complexityFilter ||
                                            algorithm.timeComplexity.average === complexityFilter ||
                                            algorithm.timeComplexity.worst === complexityFilter;

                    return matchesSearch && matchesDifficulty && matchesComplexity;
                });

                this.renderAlgorithmCards(filtered);
            }

            runAlgorithmCode() {
                alert('代码执行功能将在集成代码编辑器后实现');
            }

            getComplexityClass(complexity) {
                if (complexity.includes('O(1)') || complexity.includes('O(log n)')) {
                    return 'complexity-good';
                } else if (complexity.includes('O(n)') || complexity.includes('O(n log n)')) {
                    return 'complexity-fair';
                } else {
                    return 'complexity-poor';
                }
            }

            getDifficultyText(difficulty) {
                const difficultyMap = {
                    'easy': '简单',
                    'medium': '中等',
                    'hard': '困难'
                };
                return difficultyMap[difficulty] || difficulty;
            }

            getCategoryText(category) {
                const categoryMap = {
                    'sorting': '排序',
                    'searching': '搜索',
                    'graph': '图算法',
                    'dp': '动态规划',
                    'greedy': '贪心算法'
                };
                return categoryMap[category] || category;
            }

            getSpaceComplexityDescription(complexity) {
                const descriptions = {
                    'O(1)': '常数空间，算法只使用固定数量的额外空间',
                    'O(log n)': '对数空间，空间需求随输入规模对数增长',
                    'O(n)': '线性空间，空间需求与输入规模成正比',
                    'O(n²)': '平方空间，空间需求与输入规模的平方成正比'
                };
                return descriptions[complexity] || '空间复杂度描述';
            }
        }

        // 初始化管理器
        const algorithmsManager = new AlgorithmsManager();
    </script>
</body>
</html>